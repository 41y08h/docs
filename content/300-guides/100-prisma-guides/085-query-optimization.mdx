---
title: 'Performance and query optimization'
metaTitle: 'Performance and query optimization'
metaDescription: 'How Prisma optimizes queries under the hood'
tocDepth: 2
---

<TopBlock>

This guide describes ways to optimize query performance, debug performance issues, and how to tackle common performance issues such as the [n+1 problem](#solving-the-n1-problem).

</TopBlock>

## Debugging performance issues

To help you debug and diagnose performance issues, you can [log query events at client level](../../../concepts/components/prisma-client/working-with-prismaclient/logging#event-based-logging), which allows you to see the generated queries, parameters, and durations.

Alternatively, if you are only interested in the time taken to run a query, you can implement [logging middleware](../../../concepts/components/prisma-client/middleware/logging-middleware).

## Solving the n+1 problem

The n+1 problem occurs when you loop through the results of a query and perform one additional query **per result**, resulting in `n` number of queries plus the original (n+1). This is a common problem in ORMs because it is not always immediately obvious that your code is generating inefficient queries.

### n+1 example

The following code results in n+1 queries - one `findMany` to get all users, and one `findMany` **per user** to get each user's posts:

 <CodeWithResult expanded="{true}">
 <Cmd>

```ts
// One query to get all users
const users = await prisma.user.findMany({})

// One query PER USER to get all posts
users.forEach(async usr => {
  const posts = await prisma.post.findMany({
    where: {
      authorId: usr.id,
    },
  })

  // Do something with the users' posts
})
```

</Cmd>
<CmdResult>

```sql
SELECT "public"."User"."id", "public"."User"."email", "public"."User"."name" FROM "public"."User" WHERE 1=1 OFFSET $1
SELECT "public"."Post"."id", "public"."Post"."title" FROM "public"."Post" WHERE "public"."Post"."authorId" = $1 OFFSET $2
SELECT "public"."Post"."id", "public"."Post"."title" FROM "public"."Post" WHERE "public"."Post"."authorId" = $1 OFFSET $2
SELECT "public"."Post"."id", "public"."Post"."title" FROM "public"."Post" WHERE "public"."Post"."authorId" = $1 OFFSET $2
SELECT "public"."Post"."id", "public"."Post"."title" FROM "public"."Post" WHERE "public"."Post"."authorId" = $1 OFFSET $2
/* ..and so on .. */
```

</CmdResult>
</CodeWithResult>

This is not an efficient way to query. Depending on your requirements, there are **three ways** to get users and posts without introducing n+1:

* Use nested reads ([`include`](../../../reference/api-reference/prisma-client-reference#include) <span class="api"></span>) to return related records
* Use the [`in`](../../../reference/api-reference/prisma-client-reference#in) <span class="api"></span> filter
* Use Prisma's automatic batching of [`findUnique`](../../../reference/api-reference/prisma-client-reference#findUnique) <span class="api"></span> (particularly useful in a [GraphQL context](#example-use-findunique-to-avoid-the-n1-issue-in-your-graphql-resolvers))

### Solving n+1 with <inlinecode>include</inlinecode>

You can use `include` to return each user's posts and and only results in **two** SQL queries - one to get users, and one to get posts:
 
<CodeWithResult expanded="{true}">
<Cmd>

```ts
const usersWithPosts = await prisma.user.findMany({
  include: {
    posts: true,
  },
})
```

</Cmd>
<CmdResult>

```sql
SELECT "public"."User"."id", "public"."User"."email", "public"."User"."name" FROM "public"."User" WHERE 1=1 OFFSET $1
SELECT "public"."Post"."id", "public"."Post"."title", "public"."Post"."authorId" FROM "public"."Post" WHERE "public"."Post"."authorId" IN ($1,$2,$3,$4) OFFSET $5
```

</CmdResult>
</CodeWithResult>

### Solving n+1 with <inlinecode>in</inlinecode>

You can use the `in` filter to return all users, create a list of user IDs, then all posts where the `authorId` is `in` that list:

<CodeWithResult expanded="{true}">
<Cmd>

```ts
const users = await prisma.user.findMany({})

const userIds = users.map(x => x.id);

const posts = await prisma.post.findMany({
  where: {
    authorId: {
      in: userIds
    }
  }
})
```

</Cmd>
<CmdResult>

```
SELECT "public"."User"."id", "public"."User"."email", "public"."User"."name" FROM "public"."User" WHERE 1=1 OFFSET $1
SELECT "public"."Post"."id", "public"."Post"."createdAt", "public"."Post"."updatedAt", "public"."Post"."title", "public"."Post"."content", "public"."Post"."published", "public"."Post"."authorId" FROM "public"."Post" WHERE "public"."Post"."authorId" IN ($1,$2,$3,$4) OFFSET $5
```
</CmdResult>
</CodeWithResult>

### Solving n+1 with <inlinecode>findUnique</inlinecode>

Prisma Client automatically batches `findUnique` queries that occur in the same tick and have the same the same `where` and `include` parameters. This is particularly useful in a **GraphQL context** because GraphQL runs a separate resolver function for every field.

For example - the following GraphQL runs the `allUsers` resolver to get all users, and the `posts` resolver **once per user** to get each user's posts (n+1). Because the queries are in **separate resolvers**, you cannot solve n+1 with the `in` filter or `include`:

```js
query {
  allUsers {
    id,
    posts {
      id
    }
  }
}
```

In this scenario, you should take advantage of Prisma's automatic batching of `findUnique`. For a detailed explanation, review our [example](#example-use-findunique-to-avoid-the-n1-issue-in-your-graphql-resolvers) or watch the following video from Prisma Day 2020:

<div class="videoWrapper">

<iframe width="560" height="315" src="https://www.youtube.com/embed/7oMfBGEdwsc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</div>

#### Example: Use <inlinecode>findUnique</inlinecode> to avoid the n+1 issue in your GraphQL resolvers

This example demonstrates how to use `findUnique` to mitigate the n+1 problem in GraphQL resolvers. The following GraphQL query gets all users and and their posts:

```js
query {
  allUsers {
    id,
    posts {
      id
    }
  }
}
```

The all `allUsers` query uses `user.findMany(..)` to return all users:

```ts highlight=7;normal
const Query = objectType({
  name: 'Query',
  definition(t) {
    t.nonNull.list.nonNull.field('allUsers', {
      type: 'User',
      resolve: (_parent, _args, context) => {
        return context.prisma.user.findMany()
      },
    })
  },
})
```

This results in a single SQL query:

```js
{
  timestamp: 2021-02-19T09:43:06.332Z,
  query: 'SELECT `dev`.`User`.`id`, `dev`.`User`.`email`, `dev`.`User`.`name` FROM `dev`.`User` WHERE 1=1 LIMIT ? OFFSET ?',
  params: '[-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
```

However, the resolver function for `posts` is then invoked **once per user**. This results in a `findMany` query **per user** rather than a single `findMany` to return all posts by all users (expand CLI output to see queries).

<CodeWithResult>
<Cmd>

```ts highlight=10-13;normal;
const User = objectType({
  name: 'User',
  definition(t) {
    t.nonNull.int('id')
    t.string('name')
    t.nonNull.string('email')
    t.nonNull.list.nonNull.field('posts', {
      type: 'Post',
      resolve: (parent, _, context) => {
        return context.prisma.post.findMany({
          where: { authorId: parent.id || undefined },
        })
      },
    })
  },
})
```

</Cmd>
<CmdResult>

```js
{
  timestamp: 2021-02-19T09:43:06.343Z,
  query: 'SELECT `dev`.`Post`.`id`, `dev`.`Post`.`createdAt`, `dev`.`Post`.`updatedAt`, `dev`.`Post`.`title`, `dev`.`Post`.`content`, `dev`.`Post`.`published`, `dev`.`Post`.`viewCount`, `dev`.`Post`.`authorId` FROM `dev`.`Post` WHERE `dev`.`Post`.`authorId` = ? LIMIT ? OFFSET ?',
  params: '[1,-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
{
  timestamp: 2021-02-19T09:43:06.347Z,
  query: 'SELECT `dev`.`Post`.`id`, `dev`.`Post`.`createdAt`, `dev`.`Post`.`updatedAt`, `dev`.`Post`.`title`, `dev`.`Post`.`content`, `dev`.`Post`.`published`, `dev`.`Post`.`viewCount`, `dev`.`Post`.`authorId` FROM `dev`.`Post` WHERE `dev`.`Post`.`authorId` = ? LIMIT ? OFFSET ?',
  params: '[3,-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
{
  timestamp: 2021-02-19T09:43:06.348Z,
  query: 'SELECT `dev`.`Post`.`id`, `dev`.`Post`.`createdAt`, `dev`.`Post`.`updatedAt`, `dev`.`Post`.`title`, `dev`.`Post`.`content`, `dev`.`Post`.`published`, `dev`.`Post`.`viewCount`, `dev`.`Post`.`authorId` FROM `dev`.`Post` WHERE `dev`.`Post`.`authorId` = ? LIMIT ? OFFSET ?',
  params: '[2,-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
{
  timestamp: 2021-02-19T09:43:06.348Z,
  query: 'SELECT `dev`.`Post`.`id`, `dev`.`Post`.`createdAt`, `dev`.`Post`.`updatedAt`, `dev`.`Post`.`title`, `dev`.`Post`.`content`, `dev`.`Post`.`published`, `dev`.`Post`.`viewCount`, `dev`.`Post`.`authorId` FROM `dev`.`Post` WHERE `dev`.`Post`.`authorId` = ? LIMIT ? OFFSET ?',
  params: '[4,-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
{
  timestamp: 2021-02-19T09:43:06.348Z,
  query: 'SELECT `dev`.`Post`.`id`, `dev`.`Post`.`createdAt`, `dev`.`Post`.`updatedAt`, `dev`.`Post`.`title`, `dev`.`Post`.`content`, `dev`.`Post`.`published`, `dev`.`Post`.`viewCount`, `dev`.`Post`.`authorId` FROM `dev`.`Post` WHERE `dev`.`Post`.`authorId` = ? LIMIT ? OFFSET ?',
  params: '[5,-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
```

</CmdResult>
</CodeWithResult>

Instead, use `findUnique` in combination with [the fluent API](../../../concepts/components/prisma-client/relation-queries#fluent-api) (`.posts()`) as shown to return a user's posts:

<CodeWithResult>
<Cmd>

```ts highlight=14-18;add|10-13;delete
const User = objectType({
  name: 'User',
  definition(t) {
    t.nonNull.int('id')
    t.string('name')
    t.nonNull.string('email')
    t.nonNull.list.nonNull.field('posts', {
      type: 'Post',
      resolve: (parent, _, context) => {
        return context.prisma.post.findMany({
          where: { authorId: parent.id || undefined },
        })
        return context.prisma.user
          .findUnique({
            where: { id: parent.id || undefined },
          })
          .posts()
      },
    })
  },
})
```

</Cmd>
<CmdResult>

```js
{
  timestamp: 2021-02-19T09:59:46.340Z,
  query: 'SELECT `dev`.`User`.`id`, `dev`.`User`.`email`, `dev`.`User`.`name` FROM `dev`.`User` WHERE 1=1 LIMIT ? OFFSET ?',
  params: '[-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
{
  timestamp: 2021-02-19T09:59:46.350Z,
  query: 'SELECT `dev`.`User`.`id` FROM `dev`.`User` WHERE `dev`.`User`.`id` IN (?,?,?) LIMIT ? OFFSET ?',
  params: '[1,2,3,-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
{
  timestamp: 2021-02-19T09:59:46.350Z,
  query: 'SELECT `dev`.`Post`.`id`, `dev`.`Post`.`createdAt`, `dev`.`Post`.`updatedAt`, `dev`.`Post`.`title`, `dev`.`Post`.`content`, `dev`.`Post`.`published`, `dev`.`Post`.`viewCount`, `dev`.`Post`.`authorId` FROM `dev`.`Post` WHERE `dev`.`Post`.`authorId` IN (?,?,?) LIMIT ? OFFSET ?',
  params: '[1,2,3,-1,0]',
  duration: 0,
  target: 'quaint::connector::metrics'
}
```

</CmdResult>
</CodeWithResult>

If the `posts` resolver is invoked once per user, Prisma's DataLoader groups `findUnique` queries with the same parameters and selection set. Each group is optimized into a `findMany`, which

> **Note**: Prisma's dataloader does not currently [batch `findMany` queries automatically](https://github.com/prisma/prisma/issues/1477), which is why we recommend using `findUnique` as demonstrated.

## Using bulk queries

It is generally more performant to read and write large amounts of data in bulk - for example, inserting 50,000 records in batches of 1000 rather than as 50,000 separate inserts. Prisma Client supports the following bulk queries:

- [`createMany`](../../../reference/api-reference/prisma-client-reference#createmany) <span class="api"></span>
- [`deleteMany`](../../../reference/api-reference/prisma-client-reference#deletemany) <span class="api"></span>
- [`updateMany`](../../../reference/api-reference/prisma-client-reference#updatemany) <span class="api"></span>
- [`findMany`](../../../reference/api-reference/prisma-client-reference#findmany) <span class="api"></span>

<!-- Using <inlinecode>select</inlinecode> to limit response size -->

<!-- Pagination -->
