---
title: 'Connecting and disconnecting'
metaTitle: 'Connecting and disconnecting (Concepts)'
metaDescription: 'This page explains how database connections are handled with Prisma Client and how to manually connect and disconnect your database.'
tocDepth: 2
---

<TopBlock>

`PrismaClient` connects and disconnects from your data source using the following two methods:

- [`$connect()`](../../../../reference/api-reference/prisma-client-reference#connect-1) <span class="api"></span>
- [`$disconnect()`](../../../../reference/api-reference/prisma-client-reference#disconnect-1) <span class="api"></span>

In most cases, you **do not** need to explicitly call either of these methods. `PrismaClient` automatically connects when you run your first query, creates a [connection pool](#connection-pool), and disconnects when the Node.js process ends.

See the [connection management guide](../../../../guides/deployment/connection-management) <span class="guide"></span> for information about managing connections for different deployment paradigms (long-running processes and serverless functions).

</TopBlock>

## <inlinecode>$connect()</inlinecode>

It is not necessary to call [`$connect()`](../../../../reference/api-reference/prisma-client-reference#connect-1) <span class="api"></span> thanks to the _lazy connect_ behavior: The `PrismaClient` instance connects lazily when the first request is made to the API (`$connect()` is called for you under the hood).

### Calling <inlinecode>$connect()</inlinecode> explicitly

If you need the first request to respond instantly and cannot wait for a lazy connection to be established, you can explicitly call `prisma.$connect()` to establish a connection to the data source:

```ts
const prisma = new PrismaClient()

// run inside `async` function
await prisma.$connect()
```

## <inlinecode>$disconnect()</inlinecode>

When you call [`$disconnect()`](../../../../reference/api-reference/prisma-client-reference#disconnect-1) <span class="api"></span>, Prisma Client:

1. Runs the [`beforeExit` hook](#exit-hooks)
2. Ends the Query Engine child process and closes all connections

In a long-running application such as a GraphQL API, which constantly serves requests, it does not make sense to `$disconnect()` after each request - it takes time to establish a connection, and doing so as part of each request will slow down your application.

> **Tip**: To avoid too _many_ connections in a long-running application, we recommend that you [use a single instance of `PrismaClient` across your application](instantiate-prisma-client).

### Calling <inlinecode>$disconnect()</inlinecode> explicitly

One scenario where you should call `$disconnect()` explicitly is where a script:

1. Runs **infrequently** (for example, a scheduled job to send emails each night), which means it does not benefit from a long-running connection to the database _and_
2. Exists in the context of a **long-running application**, such as a background service. If the application never shuts down, Prisma Client never disconnects.

The following script creates a new instance of `PrismaClient`, performs a task, and then disconnects - which closes the connection pool:

```ts highlight=19;normal
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient()
const emailService = new EmailService();

async function main() {

    const allUsers = await prisma.user.findMany();
    const emails = allUsers.map(x => x.email)

    await emailService.send(emails, "Hello!");
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

If the above script runs multiple times in the context of a long-running application _without_ calling `$disconnect()`, a new connection pool is created with each new instance of `PrismaClient`.

## Connection pool

When the first connection to the database is opened (either by explicitly calling `$connect()` or running the first query) the query engine first creates a connection pool to store and manage these connections.

### Default connection pool size

The default number of connections is calculated with the following formula:

```bash
num_physical_cpus * 2 + 1
```

`num_physical_cpus` represents the number of physical CPUs on your machine. If your machine has **four** physical CPUs, your connection pool will contain **nine** connections (`4 * 2 + 1 = 9`).

### Setting the connection limit

You can specify the number of connections by explicitly setting the `connection_limit` parameter in your database connection URL. For example, with the following `datasource` configuration in your [Prisma schema](../../prisma-schema) the connection pool will have exactly five connections:

```prisma
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5"
}
```

### Recommended connection limit

The [default connection pool size](#default-connection-pool-size) represents a good starting point that can be tuned with testing. Your deployment paradigm also affects the recommended connection limit - for example, [in some serverless environments, it makes sense to set the connection limit to `1`]() <span class="guide"></span>.

### External connection poolers

In serverless environments, you might end up with 3000 concurrently running functions - even if _each_ instance has a `connection_limit` of `1`. Limit concurrency or set up a connection pooler like pgBouncer.

## Exit hooks

The `beforeExit` hook runs _before_ Prisma ends its child processes and allows you to issue queries before the client disconnects - for example, as part of a graceful shutdown of a service:

```ts
const prisma = new PrismaClient();

prisma.$on('beforeExit', async () => {
    // PrismaClient still available
    await prisma.message.create({
      data: {
        message: "Shutting down server";
      }
    })
})
```
