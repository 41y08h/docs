---
title: 'Instantiating the client'
metaTitle: 'Instantiating the client (Concepts)'
metaDescription: 'How to create and use an instance of PrismaClient in your app.'
tocDepth: 2
---

<TopBlock>

The following example demonstrates how to import and instantiate your [generated client](generating-prisma-client) from the [default path](generating-prisma-client#using-a-custom-output-path):

<TabbedContent tabs={[<FileWithIcon text="TypeScript" icon="code"/>, <FileWithIcon text="Javascript" icon="code"/>]}>

<tab>

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()
```

</tab>

<tab>

```js
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()
```

</tab>

</TabbedContent>

> **Tip**: You can further customize `PrismaClient` with [constructor parameters](../../../../reference/api-reference/prisma-client-reference#prismaclient) <span class="api"></span> - for example, set [logging levels](logging) or customize [error formatting](error-formatting).

</TopBlock>

## The the number of `PrismaClient` instances matters

Each instance of `PrismaClient` manages a [database connection pool](connection-pool), which means that a large number of clients can **exhaust the database connection limit**:

1. Each client creates its own instance of the [query engine](../query-engine).
2. Each query engine creates a [connection pool](connection-pool) with a default pool size of `num_physical_cpus * 2 + 1`. 
3. Too many connections may start to **slow down your database** and eventually lead to the following error:

    ```
    Error in connector: Error querying the database: db error: FATAL: sorry, too many clients already
        at PrismaClientFetcher.request
    ```

How to address this challenge depends on whether you are using Prisma in a [long-running application](#prismaclient-in-long-running-applications) or in a [serverless environment](#prismaclient-in-serverless-environments).

## <inlinecode>PrismaClient</inlinecode> in long-running applications

In **long-running** applications, we recommend that you:

* âœ” Create **one** instance of `PrismaClient` and re-use it across your application
* âœ” Assign `PrismaClient` to a global variable _in dev environments only_ to [prevent hot reloading from creating new instances](#prevent-hot-reloading-from-creating-new-instances-of-prismaclient)

> **Note**: You [do not need to explicitly `$disconnect()`](connection-management#calling-disconnect-explicitly) in the context of a long-running application, such as a GraphQL server.

To re-use a single instance, create a module that exports a `PrismaClient` object:

```ts file=client.ts
import { PrismaClient } from "@prisma/client"

let prisma = new PrismaClient() 

export default prisma
```

The object is [cached](https://nodejs.org/api/modules.html#modules_caching) the first time the module is imported. Subsequent requests return the cached object rather than creating a new `PrismaClient`:

```ts file=app.ts
import prisma from './client'

async function main() {
  const allUsers = await prisma.user.findMany();
}

main();
```

### Prevent hot reloading from creating new instances of `PrismaClient`

Frameworks like [Next.js](https://nextjs.org/) support hot reloading of changed files, which enables you to see changes to your application without restarting. However, if the framework refreshes the module responsible for exporting `PrismaClient`, this can result in **additional, unwanted instances of `PrismaClient` in a development environment**.

As a workaround, you can store `PrismaClient` as a global variable in development environments only, as global variables are not reloaded:

```ts file=client.ts
import { PrismaClient } from "@prisma/client"

declare global {
    namespace NodeJS {
        interface Global {
            prisma: PrismaClient;
        }
    }
}

let prisma: PrismaClient;

if (process.env.NODE_ENV === "production") {
  prisma = new PrismaClient()
} else {
  if (!global.prisma) {
    global.prisma = new PrismaClient()
  }

  prisma = global.prisma
}

export default prisma
```

The way that you import and use the client does not change:

```ts file=app.ts
import prisma from './client'

async function main() {
    const allUsers = await prisma.user.findMany();
}

main();
```

## <inlinecode>PrismaClient</inlinecode> in serverless environments

In a serverless environment, each function **creates its own instance of `PrismaClient`** and therefore has its own connection pool. Even if the `connection_limit` is set to `1`, `n` _concurrent functions_ responding to a traffic spike ðŸ“ˆ results in `n` connections.

Since you cannot create and share a single instance across functions, you must find other ways to avoid exhausting the database connection limit. Strategies include:

* Creating `PrismaClient` [outside of function handler](https://github.com/prisma/e2e-tests/blob/5d1041d3f19245d3d237d959eca94d1d796e3a52/platforms/serverless-lambda/index.ts#L3) to increase the chances of reuse
* [Setting the Prisma Client `connection_limit` to `1`](connection-pool#setting-the-connection-limit)
* Using an external [connection pooler like pgBouncer]()
* Limiting the number of concurrent functions (example: [AWS Lambda concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html))

Refer to the [connection management guide](../../../../guides/deployment/connection-management#serverless-environments-faas) <span class="guide"></span> for more information about managing database connections in serverless environments.